<!DOCTYPE html><html lang="sv"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Svampkalender | Svamphemsida</title><!-- Ladda in JavaScript-koden som anv√§nds p√• hemsidan--><!-- Om du kollar p√• output-koden, allts√• det som visas i din webbl√§sare och i dist/-mappen,--><!-- se src/-mappen i k√§llkoden f√∂r att se den faktiska k√§llkoden! Filen nedan kommer vara--><!-- minifierad med hj√§lp av bundlern Parcel.--><script src="/index.739bf03c.js" defer=""></script><!-- Ladda in CSS. Denna √§r ocks√• minifierad, se kommentaren ovan.--><link rel="stylesheet" href="/index.e8265c92.css"><!-- Ladda in faviconen.--><link rel="favicon" href="https://20alse.ssis.nu/svampbilder/favicon.ico" type="image/x-icon"></head><body class="bg-secondary"><div class="p-4" id="main"><!-- Navbar - huvudmeny p√• hemsidan--><div id="navbar-wrapper"><nav class="navbar navbar-expand-lg navbar-secondary text-white bg-primary rounded-2 my-4"><div class="container-fluid"><!-- Logga f√∂r hemsidan--><a class="navbar-brand" href="#"><img class="img-fluid" src="/website_logo.90ce6f48.png" alt="Hemsidans logga" width="256" height="96"></a><!-- Knapp f√∂r att toggla menyn (dyker upp p√• mobiler)--><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent" aria-controls="navbarContent"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarContent"><ul class="navbar-nav row text-center"><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon f√∂r menyfliken (Bootstrap Icons)--><i class="bi-house-fill bi"></i><a class="nav-link text-white p-3" href="/index.html">Startsida</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon f√∂r menyfliken (Bootstrap Icons)--><i class="bi-list-ul bi"></i><a class="nav-link text-white p-3" href="/svamplista.html">Svamplista</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon f√∂r menyfliken (Bootstrap Icons)--><i class="bi-info-square-fill bi"></i><a class="nav-link text-white p-3" href="/letarguide.html">Letarguide</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon f√∂r menyfliken (Bootstrap Icons)--><i class="bi-calendar-range-fill bi"></i><a class="nav-link text-white p-3" href="/svampkalender.html">Svampkalender</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon f√∂r menyfliken (Bootstrap Icons)--><i class="bi-envelope-fill bi"></i><a class="nav-link text-white p-3" href="mailto:20alse@stockholmscience.se">Kontakt</a></p></li></ul></div></div></nav></div><!-- Huvudinneh√•ll p√• sidan.--><div class="bg-primary text-white rounded-2 p-3" id="main-content"><h1>Svampkalender</h1><p>Nedan hittar du en "kalender" som ungef√§r visar n√§r p√• √•ret man kan plocka vissa svampar. Notera att svamps√§songer skiljer sig mycket fr√•n √•r till √•r. Detta √§r allts√• √§mnat att fungera som en fingervisning.</p><!-- Mycket du ser h√§r nedanf√∂r renderas av JavaScript med hj√§lp av filen som du i k√§llkoden hittar som calendar.js.--><!-- Fr√•n b√∂rjan √§r allts√• HTML:en nedan r√§tt s√• inneh√•llsfattigt och renderas sedan "client side" p√• anv√§ndarens dator.--><!-- (om du anv√§nder inspektorn och l√§ser denna kommentar n√§r du laddat in sidan som en sida i din webbl√§sare kommer inneh√•llet--><!-- nedan allts√• ha renderats av kod)--><div id="calendar-content"><div class="container-fluid"><div class="row"><!-- "Wrapper" f√∂r m√•nad.--><div class="col-md-10 col-sm-6"><h2 id="calendar-month">M√•nad</h2></div><!-- "Wrapper" f√∂r knappar f√∂r att v√§xla mellan m√•nader.--><div class="col-md-2 col-sm-6"><div class="row"><div class="col"><h1><i class="bi bi-caret-left-fill" id="left-button"></i></h1></div><div class="col"><h1><i class="bi bi-caret-right-fill" id="right-button"></i></h1></div></div></div></div><!-- "Wrapper" f√∂r de tre olika kategorierna svampar kan bli placerade i per m√•nad.--><div class="row align-content-around" id="calendar-elements"><!-- Inneh√•ller svampar som b√∂rjar dyka upp--><p></p><div class="col-xl-4 col-sm-12"><h3>P√• v√§g</h3><div class="container" id="on-the-way-in"></div></div><!-- Inneh√•ller svampar som det √§r stor/st√∂rre chans att hitta--><div class="col-xl-4 col-sm-12"><h3>Stor chans</h3><div class="container" id="prime-time"></div></div><!-- Inneh√•ller svampar som det b√∂rjar bli "ute" att hitta f√∂r s√§songen.--><div class="col-xl-4 col-sm-12"><h3>Snart ute</h3><div class="container" id="on-the-way-out"></div></div></div></div></div></div></div></body><!-- Jag l√§gger in JavaScript l√§ngst ner p√• sidan som skapar och initierar en kalender.--><!-- Jag renderar en skript-tag som importerar den kod som kr√§vs samt skapar sj√§lva kalendern--><!-- Om du kollar p√• denna sida fr√•n dist/-mappen eller fr√•n en webbl√§sare s√• √§r koden--><!-- minifierad. Se src/svampkalender.pug f√∂r originalkoden.--><script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"l0iMO":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "b39ccdfea4d744d4";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"kIGFG":[function(require,module,exports) {
const pug_config = require("../pug.config.js"); // Importera Pug's konfiguration f√∂r att h√§mta variabler (om svampar) fr√•n den
const calendar = require("./js/calendar.js"); // Importera skriptet f√∂r kalendern
const cal = new calendar.Calendar(document, pug_config.locals.mushroom_categories); // Skapa en ny kalender

},{"../pug.config.js":"k6ywt","./js/calendar.js":"fsVt9"}],"k6ywt":[function(require,module,exports) {
/* pug.config.js
Detta √§r en konfigurationsfil f√∂r templating-verktyget Pug.
Jag har skrivit mer om det i README.md.
Det √§r h√§r nedanf√∂r jag definierar mycket av inneh√•llet som visas p√• hemsidan
i form av texter och liknande. */ module.exports = {
    "locals": {
        "mushroom_categories": [
            {
                "title": "Soppar",
                "id": "soppar",
                "description": "Soppar \xe4r bra nyb\xf6rjarsvampar d\xe5 de \xe4r karakt\xe4ristiska och det finns ytterst f\xe5 soppar som \xe4r giftiga. D\xe4remot \xe4r de inte heller att underskatta f\xf6r den mer rutinerade svampletaren. Det \xe4r inte mycket som sl\xe5r en nytillagad sm\xf6rsopp.",
                "mushrooms": [
                    {
                        "name": "Sm\xf6rsopp",
                        "id": "smorsopp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            }
                        ],
                        "about": "Denna matsvamp \xe4r en fyrstj\xe4rnig sopp och tillh\xf6r en av de godare sopparna man kan hitta. Den har ocks\xe5 ett karakt\xe4ristiskt utseende. Det kan dock \xe4nd\xe5 vara lite knepigt att hitta ett fint exemplar. Svampen \xe4r n\xe4mligen som godast n\xe4r den inte vuxit s\xe5 l\xe4ngre. Som de flesta soppar tenderar denna att smaka s\xe4mre och ha f\xe5tt p\xe5h\xe4lsning av kryp och maskar i takt med dess \xe5lder.",
                        "appearance": "Svampen k\xe4nnetecknas av dess sm\xf6rf\xe4rgade r\xf6r p\xe5 undersidan. I regnig v\xe4derlek blir svampen \xe4ven glansig p\xe5 hatten. Yngre exemplar har en vit ring runt foten och kan ha en hinna utanf\xf6r r\xf6ren. Denna b\xf6r man ta bort.",
                        "location": "Svampen kan hittas \xf6ver hela Sverige men v\xe4xer i symbios med tall. D\xe5 den blir hal och glansig p\xe5 hatten \xe4r det ultimat att plocka den n\xe4r det \xe4r torrt ute, men om man hittar den ute i skogen en regnig dag f\xe5r man sj\xe4lvklart inte missa den.",
                        "image": "https://20alse.ssis.nu/svampbilder/smorsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 3.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/w/index.php?curid=4209808",
                            "sourceName": "walt sturgeon (Mycowalt) via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": [
                                10,
                                11
                            ]
                        }
                    },
                    {
                        "name": "Karl-Johansvamp",
                        "id": "stensopp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            },
                            {
                                "text": "nyb\xf6rjarv\xe4nlig",
                                "color": "bg-info"
                            }
                        ],
                        "about": "Vi har nog alla h\xf6rt namnet oavsett v\xe5ra erfarenheter med svamp. Detta \xe4r en femstj\xe4rning sopp som \xe4r mycket smarrig och har en mild smak med n\xf6tiga toner. Svampen \xe4r \xe4ven k\xe4nd under namnet stensopp.",
                        "appearance": "Foten p\xe5 svampen \xe4r ljusbrun eller vit och knubbig. Hatten kan vara b\xe5de ljusbrun och m\xf6rkbrun. P\xe5 yngre svampar \xe4r r\xf6ren vita och p\xe5 \xe4ldre \xe4r de gula/gulbruna.",
                        "location": "Enligt Artportalen hittar man fr\xe4mst denna svamp i s\xf6dra Sverige, men den f\xf6rekommer ocks\xe5 p\xe5 nordligare st\xe4llen.",
                        "image": "https://20alse.ssis.nu/svampbilder/karljohan.jpg",
                        "imageLicense": {
                            "type": "CC0 1.0",
                            "sourceURL": "https://www.flickr.com/photos/volvob12b/16424322871",
                            "sourceName": "Bernard Spragg via Flickr"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                6,
                                7,
                                8
                            ],
                            "primeTime": [
                                9,
                                10,
                                11
                            ],
                            "onTheWayOut": 12
                        }
                    },
                    {
                        "name": "Bj\xf6rksopp",
                        "id": "bjorksopp",
                        "badges": [],
                        "about": "En trestj\xe4rning matsvamp. \xc4ldre exemplar \xe4r inte lika goda som yngre.",
                        "appearance": "Namnet av svampen ger en ledtr\xe5d om dess utseende. Foten liknar en bj\xf6rk.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/bjorksopp.jpg",
                        "imageLicense": {
                            "type": "CC BY 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Leccinum_scabrum_Birkenr%C3%B6hrling_1.jpg",
                            "sourceName": "Holger Krisp via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Aspsopp",
                        "id": "aspsopp",
                        "badges": [],
                        "about": "Som man h\xf6r p\xe5 namnet s\xe5 v\xe4xer denna sopp tillsammans med asp. Den tillh\xf6r str\xe4vsopparna.",
                        "appearance": "Hatten \xe4r r\xf6dbrun eller orange. R\xf6ren \xe4r vita. Om man sk\xe4r svampen \xe4r snitten rodnande, men sedan \xf6verg\xe5r de till att bli svartare.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/aspsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Leccinum_aurantiacum.jpg",
                            "sourceName": "Hans Hillewaert via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Tegelsopp",
                        "id": "tegelsopp",
                        "badges": [],
                        "about": "Tegelsopp \xe4r enligt Svampguiden en av de mer fastare str\xe4vsopparna. Svampen \xe4r mild och passar likt m\xe5nga andra str\xe4vsoppar d\xe4rf\xf6r bra att ha tillsammans med andra svampar.",
                        "appearance": "Hatten \xe4r r\xf6dbrun eller orange. R\xf6ren \xe4r vita. Om man sk\xe4r svampen \xe4r snitten rodnande, men sedan \xf6verg\xe5r de till att bli svartare.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/tegelsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY 2.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://www.flickr.com/photos/demartigny/6103226302",
                            "sourceName": "Charles de Mille-Isles via Flickr"
                        },
                        "monthData": {
                            "onTheWayIn": 7,
                            "primeTime": [
                                8,
                                9
                            ],
                            "onTheWayOut": [
                                10,
                                11
                            ]
                        }
                    }
                ]
            },
            {
                "title": "Kantareller & dess kompisar",
                "id": "kantareller-och-kompisar",
                "description": "Sl\xe4ktet kantareller rymmer flera svampar, men jag har slagit ihop kantareller och v\xe4ldigt snarlika besl\xe4ktade svampar inom grannarter.",
                "mushrooms": [
                    {
                        "name": "Kantarell",
                        "id": "kantarell",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            },
                            {
                                "text": "nyb\xf6rjarv\xe4nlig",
                                "color": "bg-info"
                            }
                        ],
                        "about": 'Kantarellen h\xf6r till en v\xe5ra allra mest k\xe4nda svampar och har f\xe5tt smeknamnet "skogens guld" av en anledning. Dens popularitet beror p\xe5 flera faktorer, d\xe4ribland att den \xe4r l\xe4tt att k\xe4nna igen, att den \xe4r m\xe5ngsidig i matlagning, att den ytterst s\xe4llan \xe4r maskangripen, och sist att det finns f\xe5 saker som sl\xe5r sm\xf6rstekta kantareller.',
                        "appearance": 'Svampen \xe4r sv\xe5r att f\xf6rv\xe4xla och karakt\xe4riseras av dess guldskimrande utsida med r\xf6r i samma f\xe4rg som svampen. Hatten kan ibland vara veckad och kantareller kommer i olika former och storlekar. Den enda f\xf6rv\xe4xlingssvampen kallas "falsk kantarell" och skiljer sig en hel del fr\xe5n kantarellens utseende. S\xf6k online f\xf6r att hitta en bild om du \xe4r os\xe4ker.',
                        "location": "Arten f\xf6rekommer i l\xf6v- och barrskogar i hela Sverige, d\xe4remot begr\xe4nsat i Norrlands inland och fj\xe4llen.",
                        "image": "https://20alse.ssis.nu/svampbilder/kantareller.png",
                        "monthData": {
                            "onTheWayIn": 6,
                            "primeTime": [
                                7,
                                8,
                                9
                            ],
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Svart trumpetsvamp",
                        "id": "svart-trumpetsvamp",
                        "badges": [
                            {
                                "text": "s\xe4llsynt",
                                "color": "bg-warning"
                            }
                        ],
                        "about": "Svart trumpetsvamp \xe4r en riktigt god svamp och i mitt tycke \xe4r den underskattad. Detta kanske beror p\xe5 att den \xe4r ytterst s\xe4llsynt.",
                        "appearance": "Svart trumpetsvamp har en trattformad hatt med tunt k\xf6tt.",
                        "location": "Denna svamp hittar man ofta dold bland mossa i l\xf6v- och blandskogar. Den f\xf6rekommer (men \xe4r mer s\xe4llsynt) i norra delar av Sverige.",
                        "image": "https://20alse.ssis.nu/svampbilder/svart_trumpetsvamp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Craterellus_cornucopioides_3.jpg",
                            "sourceName": "Franck Hidv\xe9gi via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": [
                                9,
                                10
                            ],
                            "onTheWayOut": 11
                        }
                    },
                    {
                        "name": "Trattkantarell",
                        "id": "trattkantarell",
                        "badges": [],
                        "about": "H\xe4r har vi en riktigt smarrig, fyrstj\xe4rning matsvamp som dessutom inte har n\xe5gra giftiga f\xf6rv\xe4xlingssvampar om du inte \xe4r riktigt slarvig. Ofta v\xe4xer flera trattkantareller n\xe4ra varandra, s\xe5 se till att titta efter ordentligt om du hittar en!",
                        "appearance": "Hatten \xe4r tunn och brun eller ljusbrun och foten \xe4r gul. Hatten har skivor som n\xe5r ner en bit p\xe5 foten.",
                        "location": "F\xf6rekommer \xf6ver hela landet och trivs i mossig barrskog.",
                        "image": "https://20alse.ssis.nu/svampbilder/trattkantareller.png",
                        "monthData": {
                            "onTheWayIn": 9,
                            "primeTime": 10,
                            "onTheWayOut": 11
                        }
                    }
                ]
            },
            {
                "title": "Taggsvampar",
                "id": "taggsvampar",
                "description": "Endast en taggsvamp kan anses eftertraktad och f\xe5 \xe4r \xe4tliga, men om du hittar den bleka taggsvampen \xe4r ett av skogens guldfynd.",
                "mushrooms": [
                    {
                        "name": "Blek taggsvamp",
                        "id": "blek-taggsvamp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            }
                        ],
                        "about": "En femstj\xe4rning och otroligt smarrig men relativt s\xe4llsynt. Har inga farliga f\xf6rv\xe4xlingssvampar.",
                        "appearance": 'Blek f\xe4rg samt sm\xe5 "taggar" under hatten. Trillar l\xe4tt s\xf6nder vid tryck.',
                        "location": "F\xf6rekommer i m\xe5nga olika skogstyper i Sverige.",
                        "image": "https://20alse.ssis.nu/svampbilder/blek_taggsvamp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 3.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:HydnumRepandum.JPG",
                            "sourceName": "Archenzo via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": [
                                9,
                                10
                            ],
                            "onTheWayOut": 11
                        }
                    },
                    {
                        "name": "Br\xf6dticka",
                        "id": "brodticka",
                        "badges": [],
                        "about": "En enstj\xe4rning matsvamp som till skillnad fr\xe5n sin kollega, blek taggsvamp, inte \xe4r ansedd som n\xe5gon god matsvamp. Den \xe4r d\xe4remot \xe4tlig, men endast som ung. Som \xe4ldre \xe4r den inte giftig, men oaptitlig.",
                        "appearance": "Som namnet antyder p\xe5minner f\xe4rgen p\xe5 hatten om br\xf6d. Undersidan samt foten \xe4r vit och kan vara orangefl\xe4ckig.",
                        "location": "",
                        "image": "https://20alse.ssis.nu/svampbilder/brodticka.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Kr%C3%A1snoporka_%C5%BEemli%C4%8Dka_%28Albatrellus_confluens%29_11.JPG",
                            "sourceName": "svajcr via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    }
                ]
            }
        ],
        "menu_items": [
            {
                "url": "./index.pug",
                "text": "Startsida",
                "icon": "bi-house-fill"
            },
            {
                "url": "./svamplista.pug",
                "text": "Svamplista",
                "icon": "bi-list-ul"
            },
            {
                "url": "./letarguide.pug",
                "text": "Letarguide",
                "icon": "bi-info-square-fill"
            },
            {
                "url": "./svampkalender.pug",
                "text": "Svampkalender",
                "icon": "bi-calendar-range-fill"
            },
            {
                "url": "mailto:20alse@stockholmscience.se",
                "text": "Kontakt",
                "icon": "bi-envelope-fill"
            }
        ],
        "further_reading_websites": [
            {
                "title": "Svampguiden",
                "description": "Information om m\xe5nga olika svampar",
                "url": "http://svampguiden.com"
            },
            {
                "title": "Skogsskafferiet",
                "description": "Information om svampar samt andra \xe4tbara ting i naturen",
                "url": "https://www.skogsskafferiet.se/"
            },
            {
                "title": "Artportalen",
                "description": "Se vart olika svampar och v\xe4xter hittats i Sverige",
                "url": "https://www.artportalen.se/"
            },
            {
                "title": "ICA's svamprecept",
                "description": "ICA har \xf6ver 1000 olika recept p\xe5 svampr\xe4tter",
                "url": "https://www.ica.se/recept/svamp/"
            },
            {
                "title": "Coop's svamprecept",
                "description": "Coop har drygt 250 olika recept p\xe5 svamp",
                "url": "https://www.coop.se/recept/svamp/"
            }
        ],
        "image_licenses_information": {
            "CC BY-SA 3.0": {
                "url": "https://creativecommons.org/licenses/by-sa/3.0/deed.en"
            },
            "CC BY 3.0": {
                "url": "https://creativecommons.org/licenses/by/3.0/deed.en"
            },
            "CC0 1.0": {
                "url": "https://creativecommons.org/publicdomain/zero/1.0/"
            },
            "CC BY-SA 4.0": {
                "url": "https://creativecommons.org/licenses/by-sa/4.0/deed.en"
            },
            "CC BY 4.0": {
                "url": "https://creativecommons.org/licenses/by/4.0/"
            },
            "CC BY 2.0": {
                "url": "https://creativecommons.org/licenses/by/2.0/"
            }
        }
    }
};

},{}],"fsVt9":[function(require,module,exports) {
/* calendar.js
Inneh√•ller kod f√∂r att skapa, rendera och uppdatera
en svampkalender. Svampkalendern inne√•ller tre olika kolumner
f√∂r att visa n√§r man kan hitta olika svampar. */ // B√∂rja med att s√§tta lite konstanter. Notera att deras index b√∂rjar p√• 0.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Definiera klasser: se kommentarer nedan.
parcelHelpers.export(exports, "CalendarCard", ()=>CalendarCard);
parcelHelpers.export(exports, "Calendar", ()=>Calendar);
const minMonthIndex = 6; // Tidigast m√•nad f√∂r kalendern: Juli
const maxMonthIndex = 11; // Senaste m√•nad f√∂r kalendern: December
const monthNames = [
    "Januari",
    "Feburari",
    "Mars",
    "April",
    "Maj",
    "Juni",
    "Juli",
    "Augusti",
    "September",
    "Oktober",
    "November",
    "December"
];
class CalendarCard {
    /**
   * Ett CalendarCard motsvarar ett "kort" i kalendern, allts√• en svamp som visas.
   * @param {*} mushroomData Data som finns om svampen. Denna data √§r den som satts i pug.config.js
   * om varje svamp.
   */ constructor(mushroomData){
        this.mushroomData = mushroomData;
    }
    /**
   * Funktion f√∂r att rendera upp ett kalenderkort som inneh√•ller informationen om svampen.
   * @param {*} parent "F√∂r√§lderelementet" som kortet ska l√§ggas till i.
   */ createElement(parent) {
        // Skapa en div som kommer att inneh√•lla kortet med svampinfo och applicera klasser och stilar.
        const cardWrapper = document.createElement("div");
        const cardRow = document.createElement("div");
        cardWrapper.classList.add(...[
            "row"
        ]);
        cardRow.classList.add(...[
            "bg-white",
            "align-items-center",
            "rounded",
            "text-black",
            "px-4",
            "py-3",
            "border",
            "border-light",
            "my-3",
            "mx-4",
            "row"
        ]);
        // Vi vill √•stadkomma ett kort som har en titel och l√§nk som en kolumn och en bild som en kolumn,
        // bredvid varandra. D√§rf√∂r beh√∂ver vi skapa tv√• beh√•llare som ska l√§ggas till i cardWrapper.
        const [titleWrapper, imageWrapper] = [
            document.createElement("div"),
            document.createElement("div")
        ];
        // Skapa en titel f√∂r kortet
        const cardHeading = document.createElement("h4");
        cardHeading.innerHTML = this.mushroomData.name;
        // L√§gg till titel i diven vi skapade som ska inneh√•lla information
        titleWrapper.appendChild(cardHeading);
        // Sen vill vi ha en bild p√• svampen ocks√•! En bild s√§ger mer √§n tusen ord.
        const cardImage = document.createElement("img");
        cardImage.classList.add(...[
            "img-fluid",
            "h-auto",
            "w-50"
        ]);
        cardImage.src = this.mushroomData.image;
        cardImage.alt = `Bild som visar en ${this.mushroomData.name.toLowerCase()}`;
        imageWrapper.appendChild(cardImage);
        // Vi l√§gger till de ovan n√§mnda "wrapper-divsen" (kolumnerna) i kortet.
        // Vi applicerar ocks√• liknande klasser till b√•da.
        for (const childWrapper of [
            titleWrapper,
            imageWrapper
        ]){
            let classesToAppend = [];
            if (childWrapper === titleWrapper) classesToAppend.push(...[
                "col-md-8",
                "col-sm-12"
            ]);
            else classesToAppend.push(...[
                "col-md-4",
                "col-sm-12"
            ]);
            childWrapper.classList.add(...classesToAppend);
            cardRow.appendChild(childWrapper);
        }
        cardWrapper.appendChild(cardRow);
        // L√§gg till det nya kortet i dess "f√∂r√§lder" satt av argumentet parent (en av kalenderkolumnerna)
        parent.appendChild(cardWrapper);
    }
}
class Calendar {
    /**
   * Klassen Calendar representerar hela svampkalendern.
   * En kalender inneh√•ller flera CalendarCard, se ovan.
   * Genom att kalla denna klass p√• fler st√§llen kan man skapa flera
   * svampkalendrar, om man s√• √∂nskar
   * @param {*} rootElement "F√∂r√§lderelementet" d√§r kalendern ska skapas i. Detta element ska inneh√•lla n√•gra taggar med
   * vissa IDn och tomma inneh√•ll f√∂r att bli korrekt ifyllda av koden. Dessa IDs kan du hitta nedan i konstruktorn.
   * @param {*} mushroomCategories Data om alla svampar och dess kategorier. Detta argument ska motsvara
   * det format (och i mitt fall √§ven det inneh√•ll) som finns i pug.config.js under
   * "mushroom_categories"
   */ constructor(rootElement, mushroomCategories){
        console.log("Initierar en svampkalender i elementet...", rootElement);
        this.rootElement = rootElement;
        this.mushroomCategories = mushroomCategories;
        // St√§ll in den valda m√•naden till den tidigaste m√•naden och namnet till detsamma.
        this.selectedMonth = minMonthIndex;
        this.selectedMonthName = monthNames[this.selectedMonth];
        // H√§mta och spara element som kalendern uppdaterar. Dessa ska finnas i rootElement.
        this.monthTitle = rootElement.getElementById("calendar-month"); // Element f√∂r m√•nadstitel
        // Inh√§mta "f√∂r√§lderelement"/"beh√•llare" f√∂r de tre olika s√§tten som svampar ska visas: om de √§r p√• v√§g,
        // om det √§r h√∂gs√§song och om de √§r p√• v√§g ut.
        const onTheWayInWrapper = rootElement.getElementById("on-the-way-in");
        const primeTimeWrapper = rootElement.getElementById("prime-time");
        const onTheWayOutWrapper = rootElement.getElementById("on-the-way-out");
        // Initiera knappar f√∂r att v√§xla mellan m√•nader och l√§gg in event f√∂r de.
        const rightButton = rootElement.getElementById("right-button");
        const leftButton = rootElement.getElementById("left-button");
        this.onRightButtonClick = this.onRightButtonClick.bind(this);
        this.onLeftButtonClick = this.onLeftButtonClick.bind(this);
        rightButton.addEventListener("click", this.onRightButtonClick);
        leftButton.addEventListener("click", this.onLeftButtonClick);
        // Lagra de ovan inh√§mntade "beh√•llarna" f√∂r att l√§gga in svampar i
        // i ett objekt
        this.periodWrappers = {
            onTheWayIn: onTheWayInWrapper,
            primeTime: primeTimeWrapper,
            onTheWayOut: onTheWayOutWrapper
        };
        this.updateMonthsView(); // Rendera kalendern f√∂r f√∂rsta g√•ngen.
    }
    /**
   * K√∂rs varje g√•ng man har klickat p√• en knapp f√∂r att v√§xla m√•nad i svampkalendern.
   * @param {*} forward true eller false beroende p√• om knappen ska leda till att m√•naden
   * √∂kas (true) eller att m√•naden minskas (false).
   */ monthButtonClicked(forward) {
        if (forward) {
            // Om man ska g√• fram√•t
            if (this.selectedMonth < maxMonthIndex) // Kan vi g√• fram√•t?
            this.selectedMonth++;
            else // Om vi har n√•tt maxindex, g√• tillbaka till b√∂rjan
            this.selectedMonth = minMonthIndex;
        } else // Om man ska g√• bak√•t
        if (this.selectedMonth > minMonthIndex) // Kan vi g√• bak√•t
        this.selectedMonth--;
        else // Om vi har n√•tt minindex, g√• till slutet
        this.selectedMonth = maxMonthIndex;
        this.selectedMonthName = monthNames[this.selectedMonth]; // Updatera m√•nadsnamn
        console.log(`Uppdaterade m√•nad till ${this.selectedMonthName}.`);
        this.updateMonthsView(); // Uppdatera kalendern f√∂r att matcha aktuella val
    }
    /**
   * "Hj√§lpfunktion" f√∂r att iterera √∂ver svampar och deras kategorier f√∂r att hitta de svampar
   * som ska visas i n√•gon av de tre kategorierna (om de √§r p√• v√§g, om det √§r h√∂gs√§song och
   * om de √§r p√• v√§g ut) f√∂r en viss m√•nad.
   * @returns Ett objekt som inneh√•ller nycklar f√∂r de tre svampkategorierna samt en lista med svampar
   * inom respektive kategori.
   */ getMushroomsForMonth() {
        let results = {
            onTheWayIn: [],
            primeTime: [],
            onTheWayOut: []
        };
        // Iterera √∂ver alla svampkategorier
        for (const mushroomCategory of this.mushroomCategories)// Iterera √∂ver alla svampar
        for (const mushroom of mushroomCategory.mushrooms){
            // H√§mta svampens olika perioder
            if (mushroom.monthData !== undefined) // Vi vill ha en svamp f√∂r varje m√•nad
            for (const [period, periodData] of Object.entries(mushroom.monthData)){
                // M√•nadssiffror i configen √§r en st√∂rre √§n indexet i listan, eftersom index i JavaScript b√∂rjar p√• noll,
                // men m√•nadsnummer i konfigurationen f√∂r l√§sbarhetens skull b√∂rjar p√• ett.
                // D√§rf√∂r plussas m√•nadsnumret vi kollar efter i listan p√• med ett.
                const selectedMonthNumber = this.selectedMonth + 1;
                // Om datan n√§r svampen ska inkluderas i kategorin √§r en lista p√• m√•nader, kolla om aktuell m√•nad finns i den listan.
                // Om det √§r en enskild m√•nad och den st√§mmer √∂verrens med aktuell m√•nad, inkludera svampen.
                if (typeof periodData == "object" && periodData.includes(this.selectedMonth) || periodData === this.selectedMonth) {
                    console.log(`Inkluderar svamp ${mushroom.name} i ${period}...`);
                    results[period].push(new CalendarCard(mushroom));
                }
            }
            else // Fallback ifall en svamp skulle sakna m√•nadsinfo. Underl√§ttar testning.
            console.warn(`Det finns ingen m√•nadsdata f√∂r svampen ${mushroom.name}.`);
        }
        return results;
    }
    /**
   * Uppdaterar en av elementen i this.periodWrappers f√∂r att
   * inneh√•lla de svamparna som √§r aktuella f√∂r den nuvarande m√•naden.
   * @param {*} element Elementet som ska uppdateras.
   * @param {*} mushrooms Svamparna som ska finnas i elementet.
   */ updateElementTo(element, mushrooms) {
        // Rensa element
        element.innerHTML = "";
        // L√§gg till HTML f√∂r varje svamp med hj√§lp av funktionen createElement
        // i CalendarCard.
        if (mushrooms.length > 0) for (const mushroom of mushrooms)mushroom.createElement(element);
        else {
            const noMushroomsFoundText = document.createElement("h4");
            noMushroomsFoundText.innerHTML = "Inga svampar h\xe4r!";
            noMushroomsFoundText.classList.add(...[
                "text-secondary"
            ]);
            element.appendChild(noMushroomsFoundText);
        }
    }
    /**
   * Funktion f√∂r att uppdatera kalendervyn till den data som ska visas f√∂r den aktuellt utvalda
   * m√•naden. Detta √§r huvudfunktionen man ska kalla f√∂r att uppdatera gr√§nsnittet.
   */ updateMonthsView() {
        console.log("Uppdaterar kalendervyn...");
        // B√∂rja med att h√§mta svampar som ska inkluderas i kalendervyn f√∂r denna m√•nad.
        const mushroomsForCurrentMonth = this.getMushroomsForMonth();
        console.log("H\xe4mtade svampars position f\xf6r denna m\xe5nad: ", mushroomsForCurrentMonth);
        // Iterera √∂ver data f√∂r varje kategori i "kalendern":
        // 1. B√∂rjar komma
        // 2. Stor chans
        // 3. Snart ute
        for (const [periodWrapper, mushroomsInPeriod] of Object.entries(mushroomsForCurrentMonth))// Uppdatera "f√∂r√§ldern" f√∂r varje kategori/period i kalendern med de svampar som hittats
        // i perioden.
        this.updateElementTo(this.periodWrappers[periodWrapper], mushroomsInPeriod);
        // Uppdatera s√• att texten som visar aktuell m√•nad st√§mmer
        this.monthTitle.innerHTML = this.selectedMonthName;
    }
    /**
   * Funktion f√∂r n√§r n√•gon klickar p√• h√∂gerpilknappen i kalendern
   * f√∂r att g√• fram√•t en m√•nad.
   */ onRightButtonClick() {
        this.monthButtonClicked(true);
    }
    /**
   * Funktion f√∂r n√§r n√•gon klickar p√• v√§nsterpilknappen i kalendern
   * f√∂r att g√• bak√•t en m√•nad.
   */ onLeftButtonClick() {
        this.monthButtonClicked(false);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["l0iMO","kIGFG"], "kIGFG", "parcelRequire1248")

</script></html>