<!DOCTYPE html><html lang="sv"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Svampkalender | Svamphemsida</title><!-- Ladda in JavaScript-koden som används på hemsidan--><!-- Om du kollar på output-koden, alltså det som visas i din webbläsare och i dist/-mappen,--><!-- se src/-mappen i källkoden för att se den faktiska källkoden! Filen nedan kommer vara--><!-- minifierad med hjälp av bundlern Parcel.--><script src="/index.739bf03c.js" defer=""></script><!-- Ladda in CSS. Denna är också minifierad, se kommentaren ovan.--><link rel="stylesheet" href="/index.e8265c92.css"><!-- Ladda in faviconen.--><link rel="favicon" href="https://20alse.ssis.nu/svampbilder/favicon.ico" type="image/x-icon"></head><body class="bg-secondary"><div class="p-4" id="main"><!-- Navbar - huvudmeny på hemsidan--><div id="navbar-wrapper"><nav class="navbar navbar-expand-lg navbar-secondary text-white bg-primary rounded-2 my-4"><div class="container-fluid"><!-- Logga för hemsidan--><a class="navbar-brand" href="#"><img class="img-fluid" src="/website_logo.90ce6f48.png" alt="Hemsidans logga" width="256" height="96"></a><!-- Knapp för att toggla menyn (dyker upp på mobiler)--><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent" aria-controls="navbarContent"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarContent"><ul class="navbar-nav row text-center"><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon för menyfliken (Bootstrap Icons)--><i class="bi-house-fill bi"></i><a class="nav-link text-white p-3" href="/index.html">Startsida</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon för menyfliken (Bootstrap Icons)--><i class="bi-list-ul bi"></i><a class="nav-link text-white p-3" href="/svamplista.html">Svamplista</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon för menyfliken (Bootstrap Icons)--><i class="bi-info-square-fill bi"></i><a class="nav-link text-white p-3" href="/letarguide.html">Letarguide</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon för menyfliken (Bootstrap Icons)--><i class="bi-calendar-range-fill bi"></i><a class="nav-link text-white p-3" href="/svampkalender.html">Svampkalender</a></p></li><li class="nav-item col"><p class="d-flex flex-row align-items-center"><!-- Ikon för menyfliken (Bootstrap Icons)--><i class="bi-envelope-fill bi"></i><a class="nav-link text-white p-3" href="mailto:20alse@stockholmscience.se">Kontakt</a></p></li></ul></div></div></nav></div><!-- Huvudinnehåll på sidan.--><div class="bg-primary text-white rounded-2 p-3" id="main-content"><h1>Svampkalender</h1><p>Nedan hittar du en "kalender" som ungefär visar när på året man kan plocka vissa svampar. Notera att svampsäsonger skiljer sig mycket från år till år. Detta är alltså ämnat att fungera som en fingervisning.</p><!-- Mycket du ser här nedanför renderas av JavaScript med hjälp av filen som du i källkoden hittar som calendar.js.--><!-- Från början är alltså HTML:en nedan rätt så innehållsfattigt och renderas sedan "client side" på användarens dator.--><!-- (om du använder inspektorn och läser denna kommentar när du laddat in sidan som en sida i din webbläsare kommer innehållet--><!-- nedan alltså ha renderats av kod)--><div id="calendar-content"><div class="container-fluid"><div class="row"><!-- "Wrapper" för månad.--><div class="col-md-10 col-sm-6"><h2 id="calendar-month">Månad</h2></div><!-- "Wrapper" för knappar för att växla mellan månader.--><div class="col-md-2 col-sm-6"><div class="row"><div class="col"><h1><i class="bi bi-caret-left-fill" id="left-button"></i></h1></div><div class="col"><h1><i class="bi bi-caret-right-fill" id="right-button"></i></h1></div></div></div></div><!-- "Wrapper" för de tre olika kategorierna svampar kan bli placerade i per månad.--><div class="row align-content-around" id="calendar-elements"><!-- Innehåller svampar som börjar dyka upp--><p></p><div class="col-xl-4 col-sm-12"><h3>På väg</h3><div class="container" id="on-the-way-in"></div></div><!-- Innehåller svampar som det är stor/större chans att hitta--><div class="col-xl-4 col-sm-12"><h3>Stor chans</h3><div class="container" id="prime-time"></div></div><!-- Innehåller svampar som det börjar bli "ute" att hitta för säsongen.--><div class="col-xl-4 col-sm-12"><h3>Snart ute</h3><div class="container" id="on-the-way-out"></div></div></div></div></div></div></div></body><!-- Jag lägger in JavaScript längst ner på sidan som skapar och initierar en kalender.--><!-- Jag renderar en skript-tag som importerar den kod som krävs samt skapar själva kalendern--><!-- Om du kollar på denna sida från dist/-mappen eller från en webbläsare så är koden--><!-- minifierad. Se src/svampkalender.pug för originalkoden.--><script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"l0iMO":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "b39ccdfea4d744d4";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"kIGFG":[function(require,module,exports) {
const pug_config = require("../pug.config.js"); // Importera Pug's konfiguration för att hämta variabler (om svampar) från den
const calendar = require("./js/calendar.js"); // Importera skriptet för kalendern
const cal = new calendar.Calendar(document, pug_config.locals.mushroom_categories); // Skapa en ny kalender

},{"../pug.config.js":"k6ywt","./js/calendar.js":"fsVt9"}],"k6ywt":[function(require,module,exports) {
/* pug.config.js
Detta är en konfigurationsfil för templating-verktyget Pug.
Jag har skrivit mer om det i README.md.
Det är här nedanför jag definierar mycket av innehållet som visas på hemsidan
i form av texter och liknande. */ module.exports = {
    "locals": {
        "mushroom_categories": [
            {
                "title": "Soppar",
                "id": "soppar",
                "description": "Soppar \xe4r bra nyb\xf6rjarsvampar d\xe5 de \xe4r karakt\xe4ristiska och det finns ytterst f\xe5 soppar som \xe4r giftiga. D\xe4remot \xe4r de inte heller att underskatta f\xf6r den mer rutinerade svampletaren. Det \xe4r inte mycket som sl\xe5r en nytillagad sm\xf6rsopp.",
                "mushrooms": [
                    {
                        "name": "Sm\xf6rsopp",
                        "id": "smorsopp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            }
                        ],
                        "about": "Denna matsvamp \xe4r en fyrstj\xe4rnig sopp och tillh\xf6r en av de godare sopparna man kan hitta. Den har ocks\xe5 ett karakt\xe4ristiskt utseende. Det kan dock \xe4nd\xe5 vara lite knepigt att hitta ett fint exemplar. Svampen \xe4r n\xe4mligen som godast n\xe4r den inte vuxit s\xe5 l\xe4ngre. Som de flesta soppar tenderar denna att smaka s\xe4mre och ha f\xe5tt p\xe5h\xe4lsning av kryp och maskar i takt med dess \xe5lder.",
                        "appearance": "Svampen k\xe4nnetecknas av dess sm\xf6rf\xe4rgade r\xf6r p\xe5 undersidan. I regnig v\xe4derlek blir svampen \xe4ven glansig p\xe5 hatten. Yngre exemplar har en vit ring runt foten och kan ha en hinna utanf\xf6r r\xf6ren. Denna b\xf6r man ta bort.",
                        "location": "Svampen kan hittas \xf6ver hela Sverige men v\xe4xer i symbios med tall. D\xe5 den blir hal och glansig p\xe5 hatten \xe4r det ultimat att plocka den n\xe4r det \xe4r torrt ute, men om man hittar den ute i skogen en regnig dag f\xe5r man sj\xe4lvklart inte missa den.",
                        "image": "https://20alse.ssis.nu/svampbilder/smorsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 3.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/w/index.php?curid=4209808",
                            "sourceName": "walt sturgeon (Mycowalt) via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": [
                                10,
                                11
                            ]
                        }
                    },
                    {
                        "name": "Karl-Johansvamp",
                        "id": "stensopp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            },
                            {
                                "text": "nyb\xf6rjarv\xe4nlig",
                                "color": "bg-info"
                            }
                        ],
                        "about": "Vi har nog alla h\xf6rt namnet oavsett v\xe5ra erfarenheter med svamp. Detta \xe4r en femstj\xe4rning sopp som \xe4r mycket smarrig och har en mild smak med n\xf6tiga toner. Svampen \xe4r \xe4ven k\xe4nd under namnet stensopp.",
                        "appearance": "Foten p\xe5 svampen \xe4r ljusbrun eller vit och knubbig. Hatten kan vara b\xe5de ljusbrun och m\xf6rkbrun. P\xe5 yngre svampar \xe4r r\xf6ren vita och p\xe5 \xe4ldre \xe4r de gula/gulbruna.",
                        "location": "Enligt Artportalen hittar man fr\xe4mst denna svamp i s\xf6dra Sverige, men den f\xf6rekommer ocks\xe5 p\xe5 nordligare st\xe4llen.",
                        "image": "https://20alse.ssis.nu/svampbilder/karljohan.jpg",
                        "imageLicense": {
                            "type": "CC0 1.0",
                            "sourceURL": "https://www.flickr.com/photos/volvob12b/16424322871",
                            "sourceName": "Bernard Spragg via Flickr"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                6,
                                7,
                                8
                            ],
                            "primeTime": [
                                9,
                                10,
                                11
                            ],
                            "onTheWayOut": 12
                        }
                    },
                    {
                        "name": "Bj\xf6rksopp",
                        "id": "bjorksopp",
                        "badges": [],
                        "about": "En trestj\xe4rning matsvamp. \xc4ldre exemplar \xe4r inte lika goda som yngre.",
                        "appearance": "Namnet av svampen ger en ledtr\xe5d om dess utseende. Foten liknar en bj\xf6rk.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/bjorksopp.jpg",
                        "imageLicense": {
                            "type": "CC BY 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Leccinum_scabrum_Birkenr%C3%B6hrling_1.jpg",
                            "sourceName": "Holger Krisp via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Aspsopp",
                        "id": "aspsopp",
                        "badges": [],
                        "about": "Som man h\xf6r p\xe5 namnet s\xe5 v\xe4xer denna sopp tillsammans med asp. Den tillh\xf6r str\xe4vsopparna.",
                        "appearance": "Hatten \xe4r r\xf6dbrun eller orange. R\xf6ren \xe4r vita. Om man sk\xe4r svampen \xe4r snitten rodnande, men sedan \xf6verg\xe5r de till att bli svartare.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/aspsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Leccinum_aurantiacum.jpg",
                            "sourceName": "Hans Hillewaert via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": [
                                7,
                                8
                            ],
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Tegelsopp",
                        "id": "tegelsopp",
                        "badges": [],
                        "about": "Tegelsopp \xe4r enligt Svampguiden en av de mer fastare str\xe4vsopparna. Svampen \xe4r mild och passar likt m\xe5nga andra str\xe4vsoppar d\xe4rf\xf6r bra att ha tillsammans med andra svampar.",
                        "appearance": "Hatten \xe4r r\xf6dbrun eller orange. R\xf6ren \xe4r vita. Om man sk\xe4r svampen \xe4r snitten rodnande, men sedan \xf6verg\xe5r de till att bli svartare.",
                        "location": "F\xf6rekommer \xf6ver hela landet.",
                        "image": "https://20alse.ssis.nu/svampbilder/tegelsopp.jpg",
                        "imageLicense": {
                            "type": "CC BY 2.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://www.flickr.com/photos/demartigny/6103226302",
                            "sourceName": "Charles de Mille-Isles via Flickr"
                        },
                        "monthData": {
                            "onTheWayIn": 7,
                            "primeTime": [
                                8,
                                9
                            ],
                            "onTheWayOut": [
                                10,
                                11
                            ]
                        }
                    }
                ]
            },
            {
                "title": "Kantareller & dess kompisar",
                "id": "kantareller-och-kompisar",
                "description": "Sl\xe4ktet kantareller rymmer flera svampar, men jag har slagit ihop kantareller och v\xe4ldigt snarlika besl\xe4ktade svampar inom grannarter.",
                "mushrooms": [
                    {
                        "name": "Kantarell",
                        "id": "kantarell",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            },
                            {
                                "text": "nyb\xf6rjarv\xe4nlig",
                                "color": "bg-info"
                            }
                        ],
                        "about": 'Kantarellen h\xf6r till en v\xe5ra allra mest k\xe4nda svampar och har f\xe5tt smeknamnet "skogens guld" av en anledning. Dens popularitet beror p\xe5 flera faktorer, d\xe4ribland att den \xe4r l\xe4tt att k\xe4nna igen, att den \xe4r m\xe5ngsidig i matlagning, att den ytterst s\xe4llan \xe4r maskangripen, och sist att det finns f\xe5 saker som sl\xe5r sm\xf6rstekta kantareller.',
                        "appearance": 'Svampen \xe4r sv\xe5r att f\xf6rv\xe4xla och karakt\xe4riseras av dess guldskimrande utsida med r\xf6r i samma f\xe4rg som svampen. Hatten kan ibland vara veckad och kantareller kommer i olika former och storlekar. Den enda f\xf6rv\xe4xlingssvampen kallas "falsk kantarell" och skiljer sig en hel del fr\xe5n kantarellens utseende. S\xf6k online f\xf6r att hitta en bild om du \xe4r os\xe4ker.',
                        "location": "Arten f\xf6rekommer i l\xf6v- och barrskogar i hela Sverige, d\xe4remot begr\xe4nsat i Norrlands inland och fj\xe4llen.",
                        "image": "https://20alse.ssis.nu/svampbilder/kantareller.png",
                        "monthData": {
                            "onTheWayIn": 6,
                            "primeTime": [
                                7,
                                8,
                                9
                            ],
                            "onTheWayOut": 10
                        }
                    },
                    {
                        "name": "Svart trumpetsvamp",
                        "id": "svart-trumpetsvamp",
                        "badges": [
                            {
                                "text": "s\xe4llsynt",
                                "color": "bg-warning"
                            }
                        ],
                        "about": "Svart trumpetsvamp \xe4r en riktigt god svamp och i mitt tycke \xe4r den underskattad. Detta kanske beror p\xe5 att den \xe4r ytterst s\xe4llsynt.",
                        "appearance": "Svart trumpetsvamp har en trattformad hatt med tunt k\xf6tt.",
                        "location": "Denna svamp hittar man ofta dold bland mossa i l\xf6v- och blandskogar. Den f\xf6rekommer (men \xe4r mer s\xe4llsynt) i norra delar av Sverige.",
                        "image": "https://20alse.ssis.nu/svampbilder/svart_trumpetsvamp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Craterellus_cornucopioides_3.jpg",
                            "sourceName": "Franck Hidv\xe9gi via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": [
                                9,
                                10
                            ],
                            "onTheWayOut": 11
                        }
                    },
                    {
                        "name": "Trattkantarell",
                        "id": "trattkantarell",
                        "badges": [],
                        "about": "H\xe4r har vi en riktigt smarrig, fyrstj\xe4rning matsvamp som dessutom inte har n\xe5gra giftiga f\xf6rv\xe4xlingssvampar om du inte \xe4r riktigt slarvig. Ofta v\xe4xer flera trattkantareller n\xe4ra varandra, s\xe5 se till att titta efter ordentligt om du hittar en!",
                        "appearance": "Hatten \xe4r tunn och brun eller ljusbrun och foten \xe4r gul. Hatten har skivor som n\xe5r ner en bit p\xe5 foten.",
                        "location": "F\xf6rekommer \xf6ver hela landet och trivs i mossig barrskog.",
                        "image": "https://20alse.ssis.nu/svampbilder/trattkantareller.png",
                        "monthData": {
                            "onTheWayIn": 9,
                            "primeTime": 10,
                            "onTheWayOut": 11
                        }
                    }
                ]
            },
            {
                "title": "Taggsvampar",
                "id": "taggsvampar",
                "description": "Endast en taggsvamp kan anses eftertraktad och f\xe5 \xe4r \xe4tliga, men om du hittar den bleka taggsvampen \xe4r ett av skogens guldfynd.",
                "mushrooms": [
                    {
                        "name": "Blek taggsvamp",
                        "id": "blek-taggsvamp",
                        "badges": [
                            {
                                "text": "smarrig",
                                "color": "bg-success"
                            }
                        ],
                        "about": "En femstj\xe4rning och otroligt smarrig men relativt s\xe4llsynt. Har inga farliga f\xf6rv\xe4xlingssvampar.",
                        "appearance": 'Blek f\xe4rg samt sm\xe5 "taggar" under hatten. Trillar l\xe4tt s\xf6nder vid tryck.',
                        "location": "F\xf6rekommer i m\xe5nga olika skogstyper i Sverige.",
                        "image": "https://20alse.ssis.nu/svampbilder/blek_taggsvamp.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 3.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:HydnumRepandum.JPG",
                            "sourceName": "Archenzo via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": [
                                9,
                                10
                            ],
                            "onTheWayOut": 11
                        }
                    },
                    {
                        "name": "Br\xf6dticka",
                        "id": "brodticka",
                        "badges": [],
                        "about": "En enstj\xe4rning matsvamp som till skillnad fr\xe5n sin kollega, blek taggsvamp, inte \xe4r ansedd som n\xe5gon god matsvamp. Den \xe4r d\xe4remot \xe4tlig, men endast som ung. Som \xe4ldre \xe4r den inte giftig, men oaptitlig.",
                        "appearance": "Som namnet antyder p\xe5minner f\xe4rgen p\xe5 hatten om br\xf6d. Undersidan samt foten \xe4r vit och kan vara orangefl\xe4ckig.",
                        "location": "",
                        "image": "https://20alse.ssis.nu/svampbilder/brodticka.jpg",
                        "imageLicense": {
                            "type": "CC BY-SA 4.0",
                            "extraText": "Inga modifikationer av originalbilden har gjorts.",
                            "sourceURL": "https://commons.wikimedia.org/wiki/File:Kr%C3%A1snoporka_%C5%BEemli%C4%8Dka_%28Albatrellus_confluens%29_11.JPG",
                            "sourceName": "svajcr via Wikimedia Commons"
                        },
                        "monthData": {
                            "onTheWayIn": 8,
                            "primeTime": 9,
                            "onTheWayOut": 10
                        }
                    }
                ]
            }
        ],
        "menu_items": [
            {
                "url": "./index.pug",
                "text": "Startsida",
                "icon": "bi-house-fill"
            },
            {
                "url": "./svamplista.pug",
                "text": "Svamplista",
                "icon": "bi-list-ul"
            },
            {
                "url": "./letarguide.pug",
                "text": "Letarguide",
                "icon": "bi-info-square-fill"
            },
            {
                "url": "./svampkalender.pug",
                "text": "Svampkalender",
                "icon": "bi-calendar-range-fill"
            },
            {
                "url": "mailto:20alse@stockholmscience.se",
                "text": "Kontakt",
                "icon": "bi-envelope-fill"
            }
        ],
        "further_reading_websites": [
            {
                "title": "Svampguiden",
                "description": "Information om m\xe5nga olika svampar",
                "url": "http://svampguiden.com"
            },
            {
                "title": "Skogsskafferiet",
                "description": "Information om svampar samt andra \xe4tbara ting i naturen",
                "url": "https://www.skogsskafferiet.se/"
            },
            {
                "title": "Artportalen",
                "description": "Se vart olika svampar och v\xe4xter hittats i Sverige",
                "url": "https://www.artportalen.se/"
            },
            {
                "title": "ICA's svamprecept",
                "description": "ICA har \xf6ver 1000 olika recept p\xe5 svampr\xe4tter",
                "url": "https://www.ica.se/recept/svamp/"
            },
            {
                "title": "Coop's svamprecept",
                "description": "Coop har drygt 250 olika recept p\xe5 svamp",
                "url": "https://www.coop.se/recept/svamp/"
            }
        ],
        "image_licenses_information": {
            "CC BY-SA 3.0": {
                "url": "https://creativecommons.org/licenses/by-sa/3.0/deed.en"
            },
            "CC BY 3.0": {
                "url": "https://creativecommons.org/licenses/by/3.0/deed.en"
            },
            "CC0 1.0": {
                "url": "https://creativecommons.org/publicdomain/zero/1.0/"
            },
            "CC BY-SA 4.0": {
                "url": "https://creativecommons.org/licenses/by-sa/4.0/deed.en"
            },
            "CC BY 4.0": {
                "url": "https://creativecommons.org/licenses/by/4.0/"
            },
            "CC BY 2.0": {
                "url": "https://creativecommons.org/licenses/by/2.0/"
            }
        }
    }
};

},{}],"fsVt9":[function(require,module,exports) {
/* calendar.js
Innehåller kod för att skapa, rendera och uppdatera
en svampkalender. Svampkalendern inneåller tre olika kolumner
för att visa när man kan hitta olika svampar. */ // Börja med att sätta lite konstanter. Notera att deras index börjar på 0.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Definiera klasser: se kommentarer nedan.
parcelHelpers.export(exports, "CalendarCard", ()=>CalendarCard);
parcelHelpers.export(exports, "Calendar", ()=>Calendar);
const minMonthIndex = 6; // Tidigast månad för kalendern: Juli
const maxMonthIndex = 11; // Senaste månad för kalendern: December
const monthNames = [
    "Januari",
    "Feburari",
    "Mars",
    "April",
    "Maj",
    "Juni",
    "Juli",
    "Augusti",
    "September",
    "Oktober",
    "November",
    "December"
];
class CalendarCard {
    /**
   * Ett CalendarCard motsvarar ett "kort" i kalendern, alltså en svamp som visas.
   * @param {*} mushroomData Data som finns om svampen. Denna data är den som satts i pug.config.js
   * om varje svamp.
   */ constructor(mushroomData){
        this.mushroomData = mushroomData;
    }
    /**
   * Funktion för att rendera upp ett kalenderkort som innehåller informationen om svampen.
   * @param {*} parent "Förälderelementet" som kortet ska läggas till i.
   */ createElement(parent) {
        // Skapa en div som kommer att innehålla kortet med svampinfo och applicera klasser och stilar.
        const cardWrapper = document.createElement("div");
        const cardRow = document.createElement("div");
        cardWrapper.classList.add(...[
            "row"
        ]);
        cardRow.classList.add(...[
            "bg-white",
            "align-items-center",
            "rounded",
            "text-black",
            "px-4",
            "py-3",
            "border",
            "border-light",
            "my-3",
            "mx-4",
            "row"
        ]);
        // Vi vill åstadkomma ett kort som har en titel och länk som en kolumn och en bild som en kolumn,
        // bredvid varandra. Därför behöver vi skapa två behållare som ska läggas till i cardWrapper.
        const [titleWrapper, imageWrapper] = [
            document.createElement("div"),
            document.createElement("div")
        ];
        // Skapa en titel för kortet
        const cardHeading = document.createElement("h4");
        cardHeading.innerHTML = this.mushroomData.name;
        // Lägg till titel i diven vi skapade som ska innehålla information
        titleWrapper.appendChild(cardHeading);
        // Sen vill vi ha en bild på svampen också! En bild säger mer än tusen ord.
        const cardImage = document.createElement("img");
        cardImage.classList.add(...[
            "img-fluid",
            "h-auto",
            "w-50"
        ]);
        cardImage.src = this.mushroomData.image;
        cardImage.alt = `Bild som visar en ${this.mushroomData.name.toLowerCase()}`;
        imageWrapper.appendChild(cardImage);
        // Vi lägger till de ovan nämnda "wrapper-divsen" (kolumnerna) i kortet.
        // Vi applicerar också liknande klasser till båda.
        for (const childWrapper of [
            titleWrapper,
            imageWrapper
        ]){
            let classesToAppend = [];
            if (childWrapper === titleWrapper) classesToAppend.push(...[
                "col-md-8",
                "col-sm-12"
            ]);
            else classesToAppend.push(...[
                "col-md-4",
                "col-sm-12"
            ]);
            childWrapper.classList.add(...classesToAppend);
            cardRow.appendChild(childWrapper);
        }
        cardWrapper.appendChild(cardRow);
        // Lägg till det nya kortet i dess "förälder" satt av argumentet parent (en av kalenderkolumnerna)
        parent.appendChild(cardWrapper);
    }
}
class Calendar {
    /**
   * Klassen Calendar representerar hela svampkalendern.
   * En kalender innehåller flera CalendarCard, se ovan.
   * Genom att kalla denna klass på fler ställen kan man skapa flera
   * svampkalendrar, om man så önskar
   * @param {*} rootElement "Förälderelementet" där kalendern ska skapas i. Detta element ska innehålla några taggar med
   * vissa IDn och tomma innehåll för att bli korrekt ifyllda av koden. Dessa IDs kan du hitta nedan i konstruktorn.
   * @param {*} mushroomCategories Data om alla svampar och dess kategorier. Detta argument ska motsvara
   * det format (och i mitt fall även det innehåll) som finns i pug.config.js under
   * "mushroom_categories"
   */ constructor(rootElement, mushroomCategories){
        console.log("Initierar en svampkalender i elementet...", rootElement);
        this.rootElement = rootElement;
        this.mushroomCategories = mushroomCategories;
        // Ställ in den valda månaden till den tidigaste månaden och namnet till detsamma.
        this.selectedMonth = minMonthIndex;
        this.selectedMonthName = monthNames[this.selectedMonth];
        // Hämta och spara element som kalendern uppdaterar. Dessa ska finnas i rootElement.
        this.monthTitle = rootElement.getElementById("calendar-month"); // Element för månadstitel
        // Inhämta "förälderelement"/"behållare" för de tre olika sätten som svampar ska visas: om de är på väg,
        // om det är högsäsong och om de är på väg ut.
        const onTheWayInWrapper = rootElement.getElementById("on-the-way-in");
        const primeTimeWrapper = rootElement.getElementById("prime-time");
        const onTheWayOutWrapper = rootElement.getElementById("on-the-way-out");
        // Initiera knappar för att växla mellan månader och lägg in event för de.
        const rightButton = rootElement.getElementById("right-button");
        const leftButton = rootElement.getElementById("left-button");
        this.onRightButtonClick = this.onRightButtonClick.bind(this);
        this.onLeftButtonClick = this.onLeftButtonClick.bind(this);
        rightButton.addEventListener("click", this.onRightButtonClick);
        leftButton.addEventListener("click", this.onLeftButtonClick);
        // Lagra de ovan inhämntade "behållarna" för att lägga in svampar i
        // i ett objekt
        this.periodWrappers = {
            onTheWayIn: onTheWayInWrapper,
            primeTime: primeTimeWrapper,
            onTheWayOut: onTheWayOutWrapper
        };
        this.updateMonthsView(); // Rendera kalendern för första gången.
    }
    /**
   * Körs varje gång man har klickat på en knapp för att växla månad i svampkalendern.
   * @param {*} forward true eller false beroende på om knappen ska leda till att månaden
   * ökas (true) eller att månaden minskas (false).
   */ monthButtonClicked(forward) {
        if (forward) {
            // Om man ska gå framåt
            if (this.selectedMonth < maxMonthIndex) // Kan vi gå framåt?
            this.selectedMonth++;
            else // Om vi har nått maxindex, gå tillbaka till början
            this.selectedMonth = minMonthIndex;
        } else // Om man ska gå bakåt
        if (this.selectedMonth > minMonthIndex) // Kan vi gå bakåt
        this.selectedMonth--;
        else // Om vi har nått minindex, gå till slutet
        this.selectedMonth = maxMonthIndex;
        this.selectedMonthName = monthNames[this.selectedMonth]; // Updatera månadsnamn
        console.log(`Uppdaterade månad till ${this.selectedMonthName}.`);
        this.updateMonthsView(); // Uppdatera kalendern för att matcha aktuella val
    }
    /**
   * "Hjälpfunktion" för att iterera över svampar och deras kategorier för att hitta de svampar
   * som ska visas i någon av de tre kategorierna (om de är på väg, om det är högsäsong och
   * om de är på väg ut) för en viss månad.
   * @returns Ett objekt som innehåller nycklar för de tre svampkategorierna samt en lista med svampar
   * inom respektive kategori.
   */ getMushroomsForMonth() {
        let results = {
            onTheWayIn: [],
            primeTime: [],
            onTheWayOut: []
        };
        // Iterera över alla svampkategorier
        for (const mushroomCategory of this.mushroomCategories)// Iterera över alla svampar
        for (const mushroom of mushroomCategory.mushrooms){
            // Hämta svampens olika perioder
            if (mushroom.monthData !== undefined) // Vi vill ha en svamp för varje månad
            for (const [period, periodData] of Object.entries(mushroom.monthData)){
                // Månadssiffror i configen är en större än indexet i listan, eftersom index i JavaScript börjar på noll,
                // men månadsnummer i konfigurationen för läsbarhetens skull börjar på ett.
                // Därför plussas månadsnumret vi kollar efter i listan på med ett.
                const selectedMonthNumber = this.selectedMonth + 1;
                // Om datan när svampen ska inkluderas i kategorin är en lista på månader, kolla om aktuell månad finns i den listan.
                // Om det är en enskild månad och den stämmer överrens med aktuell månad, inkludera svampen.
                if (typeof periodData == "object" && periodData.includes(this.selectedMonth) || periodData === this.selectedMonth) {
                    console.log(`Inkluderar svamp ${mushroom.name} i ${period}...`);
                    results[period].push(new CalendarCard(mushroom));
                }
            }
            else // Fallback ifall en svamp skulle sakna månadsinfo. Underlättar testning.
            console.warn(`Det finns ingen månadsdata för svampen ${mushroom.name}.`);
        }
        return results;
    }
    /**
   * Uppdaterar en av elementen i this.periodWrappers för att
   * innehålla de svamparna som är aktuella för den nuvarande månaden.
   * @param {*} element Elementet som ska uppdateras.
   * @param {*} mushrooms Svamparna som ska finnas i elementet.
   */ updateElementTo(element, mushrooms) {
        // Rensa element
        element.innerHTML = "";
        // Lägg till HTML för varje svamp med hjälp av funktionen createElement
        // i CalendarCard.
        if (mushrooms.length > 0) for (const mushroom of mushrooms)mushroom.createElement(element);
        else {
            const noMushroomsFoundText = document.createElement("h4");
            noMushroomsFoundText.innerHTML = "Inga svampar h\xe4r!";
            noMushroomsFoundText.classList.add(...[
                "text-secondary"
            ]);
            element.appendChild(noMushroomsFoundText);
        }
    }
    /**
   * Funktion för att uppdatera kalendervyn till den data som ska visas för den aktuellt utvalda
   * månaden. Detta är huvudfunktionen man ska kalla för att uppdatera gränsnittet.
   */ updateMonthsView() {
        console.log("Uppdaterar kalendervyn...");
        // Börja med att hämta svampar som ska inkluderas i kalendervyn för denna månad.
        const mushroomsForCurrentMonth = this.getMushroomsForMonth();
        console.log("H\xe4mtade svampars position f\xf6r denna m\xe5nad: ", mushroomsForCurrentMonth);
        // Iterera över data för varje kategori i "kalendern":
        // 1. Börjar komma
        // 2. Stor chans
        // 3. Snart ute
        for (const [periodWrapper, mushroomsInPeriod] of Object.entries(mushroomsForCurrentMonth))// Uppdatera "föräldern" för varje kategori/period i kalendern med de svampar som hittats
        // i perioden.
        this.updateElementTo(this.periodWrappers[periodWrapper], mushroomsInPeriod);
        // Uppdatera så att texten som visar aktuell månad stämmer
        this.monthTitle.innerHTML = this.selectedMonthName;
    }
    /**
   * Funktion för när någon klickar på högerpilknappen i kalendern
   * för att gå framåt en månad.
   */ onRightButtonClick() {
        this.monthButtonClicked(true);
    }
    /**
   * Funktion för när någon klickar på vänsterpilknappen i kalendern
   * för att gå bakåt en månad.
   */ onLeftButtonClick() {
        this.monthButtonClicked(false);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["l0iMO","kIGFG"], "kIGFG", "parcelRequire1248")

</script></html>